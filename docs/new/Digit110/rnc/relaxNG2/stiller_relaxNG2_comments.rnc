start = root
root = element root {poem, publishing, additional}
poem = element poem { title, text, author, stanza}
title = element title { u }
u = element u {text}

author = element author {text, signature*}

stanza = element stanza {verse+}
verse = element verse {mixed{ sentence*, ref*, xmlid*, u*}}
sentence = element sentence {num, mark}

ref = attribute ref {list {("l-5" | "l-6" | "l-7" | "l-8" | "l-9" | "l-10")+}}
# ebb: I'm modifying this to show how the list{} syntax works in Relax NG to show how it can
# validate your XML. Unfortunately, Relax won't permit xsd:IDREF to be multiple, so we have 
# to turn to a different schema validation language, Schematron, for that. Let's talk more about
# that when we get to work on the XPath unit, or if you want to use this kind of pointing in a project.
xmlid = attribute xml:id {xsd:ID} #ws: syntax error showing up by using xml:id as the label. Label changed to xmlid
# 2022-09-23 ebb: Excellent self-correction here, Will. That's precisely what you need to do to escape the RElax NG syntax issue with xml:id
# We'd do the same thing with defining an element <text>. 


num = attribute num {xsd:int}

mark = attribute mark {"start"}


publishing = element publishing {author, mixed {edition, location, date, citation}} #ws: a stray comma or some short text forces a mixed content, because it's not part of the location, date, or edition.
#ws: refering to author up above
# ebb: Yes, you have properly understood why this is mixed{} syntax. That's not a problem but it's better if 
# the decision to used mixed{} is *deliberate* (like for marking names inside paragraphs of text). In this case I think 
# I'd recommend just removing the stray commma (it's pseudomarkup here anyway), and replacing it with markup,  
# which just simplifies the structure, not requiring mixed{}.
signature = element signature {text}

edition = element edition {text}
location = element location {text}
date = element date {text} #ws: was hoping to find dataref for the date, but couldn't find one that fit the format
# ebb: For this, I typically add an attribute like @when, and then provide the ISO datatype for the date like this:
# date = element date {when, text}
# when = attribute when {xsd:date | xsd:gYearMonth | xsd:gYear}
#
# That allows something like: <date when="1941-06-01">June 1, 1941</date>
# It *also* allows for dates where the information isn't complete: just the year and month, or just the year. 

citation = element citation {text}


additional = element additional {marks, commentary}
marks = element marks {stamp}
stamp = element stamp {(xmlid | ref), text} #ws: the last error that I have and couldn't figure out was on line 75 of the xml. xmlid in .rnc couldn't handle an array(?) of values, despite the .xml separating values with spaces. Assuming xsd:ID can't handle spaces, but no idea how to fix.
# ebb:  Yes, there's a problem with validating ne of your @xml:id on <stamp>, and it's where you have a whole series of them listed.
# Here's the issue: You're pointing to multiple xml:ids in a series, so you need to be able to permit that in the Relax NG
# There's a special syntax for that called list{} and actually you're not really *identifying* those ids but *pointing* to them
# where you already defined them earlier in the document. Conceptually, think of what you're doing as referring to 
# all the different places where the stamp hits the document (places you've marked w/ xml:ids). Here I'd use your ref attribute instead
# AND you need to make sure that the value of ref permits multiple values (called "tokens"). When this is allowed, the separator
# is a space. You need a special Relax NG rule for this called list{} and it's coded a little like mixed{} content.
# I modified your rule for the @ref attribute so you can see how it works. 
# The PROBLEM as you'll immediately see is:
# I had to input literal string values for that to work, and it wouldn't permit us to handle multiple xsd:IDREF values. :-(
# That's a serious limitation we run into with Relax NG and it's why we have an alternative validation langauge called
# Schematron, which will let us better validate situations where we have multiple references pointing back to the same xml:id. 
# Ask me more about this and I'll show you how it works: it depends on XPath functions to check and validate refs against id's.

# About list{} I wrote up a GitHub post about this years ago, that might be interesting as a fuller explanation:
# https://github.com/ebeshero/DHClass-Hub/issues/59
commentary = element commentary {resp, note+}
note = element note {xmlid, text}

resp = attribute resp {"willstill"}

